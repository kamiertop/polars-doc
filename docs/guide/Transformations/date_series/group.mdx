# 分组

## 按固定窗口分组

可以使用`group_by_dynamic`将数据行按照天/月/年等分组

下面代码生成一份7行的数据(可以在group_by_dynamic的文档中看到)
```python
import polars as pl
from datetime import datetime
df = pl.DataFrame(
    {
        "time": pl.datetime_range(
            start=datetime(2021, 12, 16),
            end=datetime(2021, 12, 16, 3),
            interval="30m",
            eager=True,
        ),
        "n": range(7),
    }
)
print(df)
````

```text
shape: (7, 2)
┌─────────────────────┬─────┐
│ time                ┆ n   │
│ ---                 ┆ --- │
│ datetime[μs]        ┆ i64 │
╞═════════════════════╪═════╡
│ 2021-12-16 00:00:00 ┆ 0   │
│ 2021-12-16 00:30:00 ┆ 1   │
│ 2021-12-16 01:00:00 ┆ 2   │
│ 2021-12-16 01:30:00 ┆ 3   │
│ 2021-12-16 02:00:00 ┆ 4   │
│ 2021-12-16 02:30:00 ┆ 5   │
│ 2021-12-16 03:00:00 ┆ 6   │
└─────────────────────┴─────┘
```

接下来我们按小时分组, 然后统计n这一列的和
```python
res = df.group_by_dynamic(pl.col("time"), every="1h").agg(pl.sum("n"))

print(res)
```
```text
shape: (4, 2)
┌─────────────────────┬─────┐
│ time                ┆ n   │
│ ---                 ┆ --- │
│ datetime[μs]        ┆ i64 │
╞═════════════════════╪═════╡
│ 2021-12-16 00:00:00 ┆ 1   │
│ 2021-12-16 01:00:00 ┆ 5   │
│ 2021-12-16 02:00:00 ┆ 9   │
│ 2021-12-16 03:00:00 ┆ 6   │
└─────────────────────┴─────┘
```

:::info
日期这一列按照升序排列, 如果不按照此顺序排列, 输出结果是错误的
:::

## `group_by_dynamic`参数

- `every`: 窗口间隔
    - 1y: 表示每年开一个新窗口
    - 2y: 表示每2年开一个新窗口
    - 1h: 表示每小时开始一个新窗口
- `period`: 表示窗口的长度, 设置每个组的时间段
    - `every="1d"`, `period="2d"`, 表示每天开一窗口, 每个窗口持续2天, 窗口如下
    - 第一个窗口：2024-01-01 → 2024-01-03
    - 第二个窗口：2024-01-02 → 2024-01-04
    - 第三个窗口：2024-01-03 → 2024-01-05
- `offset`: 每个窗口的起点相对于自然对齐的偏移, 可以理解为窗口起点的偏移量
    - `every="1mo"`, `period="1mo"`: 表示每个月开一个窗口, 每个窗口的持续时间是1个月
        - [2024-01-01 → 2024-02-01)
        - [2024-02-01 → 2024-03-01)
    - `every="1mo"`, `period="1mo"`, `offset="15d"`: 窗口起点向后偏移15天, 从每个月的16号开始
        - [2024-01-16 → 2024-02-16)
        - [2024-02-16 → 2024-03-16)

## 配合表达式使用
下面示例计算: 一个月的天数
```python
from datetime import date
df = (
    pl.date_range(
        start=date(2021, 1, 1),
        end=date(2021, 12, 31),
        interval="1d",
        eager=True,
    )
    .alias("time")
    .to_frame()
)
out = (
	df.group_by_dynamic("time", every="1mo", period="1mo", closed="left")
    .agg(
            ((pl.col("time") - pl.col("time").first()).last().dt.total_days() + 1).alias("days_in_month")
    )
)
print(out)
```
等效的更好阅读的写法(上面写法是官方文档的写法):
```python
out = (
	df.group_by_dynamic("time", every="1mo", period="1mo", closed="left")
    .agg(
        # 分组后令每组的最大值-每组的最小值, 最后+1
        ((pl.col("time").max()-pl.col("time").min()).dt.total_days()+1)
	    .alias("days_in_month")
    )
)
```
```text
shape: (12, 2)
┌────────────┬───────────────┐
│ time       ┆ days_in_month │
│ ---        ┆ ---           │
│ date       ┆ i64           │
╞════════════╪═══════════════╡
│ 2021-01-01 ┆ 31            │
│ 2021-02-01 ┆ 28            │
│ 2021-03-01 ┆ 31            │
│ 2021-04-01 ┆ 30            │
│ 2021-05-01 ┆ 31            │
│ …          ┆ …             │
│ 2021-08-01 ┆ 31            │
│ 2021-09-01 ┆ 30            │
│ 2021-10-01 ┆ 31            │
│ 2021-11-01 ┆ 30            │
│ 2021-12-01 ┆ 31            │
└────────────┴───────────────┘
```

## `group_by`参数

我们还可以使用`group_by`参数再次分组

```python
df = pl.DataFrame(
    {
        "time": pl.datetime_range(
            start=datetime(2021, 12, 16),
            end=datetime(2021, 12, 16, 3),
            interval="30m",
            eager=True,
        ),
        "groups": ["a", "a", "a", "b", "b", "a", "a"],
    }
)
print(df)
```
```text
shape: (7, 2)
┌─────────────────────┬────────┐
│ time                ┆ groups │
│ ---                 ┆ ---    │
│ datetime[μs]        ┆ str    │
╞═════════════════════╪════════╡
│ 2021-12-16 00:00:00 ┆ a      │
│ 2021-12-16 00:30:00 ┆ a      │
│ 2021-12-16 01:00:00 ┆ a      │
│ 2021-12-16 01:30:00 ┆ b      │
│ 2021-12-16 02:00:00 ┆ b      │
│ 2021-12-16 02:30:00 ┆ a      │
│ 2021-12-16 03:00:00 ┆ a      │
└─────────────────────┴────────┘
```
认真比对结果和数据集就可以看明白
```python
out = df.group_by_dynamic(
    "time",
    every="1h",
	period="1h",
    group_by="groups",
	closed="both"   # 包含左右边界
).agg(pl.len())
print(out)
```
```text
shape: (6, 3)
┌────────┬─────────────────────┬─────┐
│ groups ┆ time                ┆ len │
│ ---    ┆ ---                 ┆ --- │
│ str    ┆ datetime[μs]        ┆ u32 │
╞════════╪═════════════════════╪═════╡
│ a      ┆ 2021-12-16 00:00:00 ┆ 3   │
│ a      ┆ 2021-12-16 01:00:00 ┆ 1   │
│ a      ┆ 2021-12-16 02:00:00 ┆ 2   │
│ a      ┆ 2021-12-16 03:00:00 ┆ 1   │
│ b      ┆ 2021-12-16 01:00:00 ┆ 2   │
│ b      ┆ 2021-12-16 02:00:00 ┆ 1   │
└────────┴─────────────────────┴─────┘
```